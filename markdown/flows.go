package markdown

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/yuin/goldmark/ast"
	"go.abhg.dev/goldmark/frontmatter"
)

type (
	Command map[string]Param

	Flow struct {
		If       string  `yaml:"if"`
		Command  Command `yaml:"command" validate:"required_without_all=On Schedule,omitempty,command"`
		On       string  `yaml:"on" validate:"required_without_all=Command Schedule"`
		Schedule string  `yaml:"schedule" validate:"required_without_all=On Command,omitempty,standard_cron"`
		Worker   string  `yaml:"worker"`
		// Calculated fields
		ID           string
		ifExpression hcl.Expression
		markdown     ast.Node
		path         string
	}

	FlowIndex map[string][]*Flow

	FlowReader struct {
		index          FlowIndex
		basePath       string
		md             *Markdown
		scheduledFlows []*Flow
	}

	Param struct {
		Type     string `yaml:"type"`
		Default  any    `yaml:"default"`
		Required bool   `yaml:"required"`
	}
)

func NewFlowReader(basePath string) *FlowReader {
	return &FlowReader{
		basePath: basePath,
		index:    FlowIndex{},
		md:       NewMarkdownHTML(),
	}
}

func (fr *FlowReader) AddToIndex(index string, flow *Flow) {
	indexFlows, ok := fr.index[index]
	if !ok {
		fr.index[index] = []*Flow{flow}
		return
	}

	fr.index[index] = append(indexFlows, flow)
}

func (fr *FlowReader) ReadAll() (FlowIndex, error) {
	fr.clear()

	baseDepth := strings.Count(fr.basePath, string(os.PathSeparator))

	err := filepath.WalkDir(fr.basePath, func(path string, de fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Only go one sub-directory deep
		if de.IsDir() && strings.Count(path, string(os.PathSeparator)) > baseDepth+1 {
			return fs.SkipDir
		}

		if de.IsDir() {
			return nil
		}

		if strings.ToLower(filepath.Ext(path)) != ".md" {
			return nil
		}

		flow, err := fr.ReadFlow(path)
		if err != nil {
			return err
		}

		if err := fr.indexFlow(flow); err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("unable to read flow files: %w", err)
	}

	return fr.index, nil
}

func (fr *FlowReader) ReadFlow(path string) (*Flow, error) {
	ast, pCtx, err := fr.md.ParseFile(path)
	if err != nil {
		return nil, fmt.Errorf("unable to load flow: %w", err)
	}

	f := &Flow{path: path}
	fm := frontmatter.Get(pCtx)
	if fm == nil {
		return nil, fmt.Errorf("flow does not contain any fields")
	}

	if err := fm.Decode(f); err != nil {
		return nil, fmt.Errorf("unable to decode flow: %w", err)
	}

	flowDirName := filepath.Base(filepath.Dir(path))
	fileName := strings.TrimSuffix(filepath.Base(path), filepath.Ext(path))

	f.markdown = ast
	f.ID = fmt.Sprintf("%s.%s", flowDirName, fileName)

	if f.Worker == "" {
		f.Worker = f.ID
	}

	// Convert relative worker names to absolute ones
	if !strings.Contains(f.Worker, ".") {
		f.Worker = fmt.Sprintf("%s.%s", flowDirName, f.Worker)
	}

	if f.If != "" {
		expr, diags := hclsyntax.ParseExpression([]byte(f.If), path, hcl.InitialPos)
		if diags.HasErrors() {
			return nil, errors.Join(diags.Errs()...)
		}

		f.ifExpression = expr
	}

	if err := flowValidator.validate.Struct(f); err != nil {
		return nil, err
	}

	return f, nil
}

// ScheduledFlows returns all flows that have a schedule configured
func (fr *FlowReader) ScheduledFlows() []*Flow {
	return fr.scheduledFlows
}

// clear resets internal caches of flows
//
//	It is used to avoid accumulating duplicate flows on reload
func (fr *FlowReader) clear() {
	fr.index = FlowIndex{}
	fr.scheduledFlows = []*Flow{}
}

func (fr *FlowReader) indexFlow(flow *Flow) error {
	// Create index for `on`
	// First expand the on statement with wildcards in case parts have been
	// omitted using the shorthand syntax
	var on string
	splitOn := strings.Split(flow.On, ".")
	switch len(splitOn) {
	case 1:
		on = fmt.Sprintf("*.%s.*", flow.On)
	case 2:
		on = fmt.Sprintf("*.%s", flow.On)
	case 3:
		on = flow.On
	default:
		return fmt.Errorf("invalid 'on' field, must be defined and have no more than three parts")
	}
	fr.AddToIndex(on, flow)

	// Create index for command
	if flow.Command != nil {
		fr.AddToIndex(fmt.Sprintf("hiphops.command.%s", flow.ActionName()), flow)
	}

	// Create index for schedule
	if flow.Schedule != "" {
		fr.scheduledFlows = append(fr.scheduledFlows, flow)
		fr.AddToIndex(fmt.Sprintf("hiphops.schedule.%s", flow.ActionName()), flow)
	}

	return nil
}

// ActionName returns the name of the action for events generated by this flow
//
// Note: schedules and commands both generate events
func (f *Flow) ActionName() string {
	return strings.ReplaceAll(f.ID, ".", "-")
}
